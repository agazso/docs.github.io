(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{106:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return u}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),h=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=h(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=h(n),p=a,u=d["".concat(r,".").concat(p)]||d[p]||b[p]||i;return n?o.a.createElement(u,s(s({ref:t},l),{},{components:n})):o.a.createElement(u,s({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},62:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return h}));var a=n(2),o=n(6),i=(n(0),n(106)),r={title:"Persistence",id:"persistence"},s={unversionedId:"advanced/persistence",id:"advanced/persistence",isDocsHomePage:!1,title:"Persistence",description:"The storage capacity of the whole Swarm network equals the the sum of the storage capacity of all connected nodes. As nobody is restricted to upload content to Swarm, eventually the storage capacity of the Swarm network reaches its limits and nodes face the choice to either stop accepting new chunks or delete content which is there already for a while.",source:"@site/docs/advanced/persistence.md",permalink:"/docs/advanced/persistence",editUrl:"https://github.com/ethersphere/docs.github.io/docs/advanced/persistence.md",sidebar:"someSidebar",previous:{title:"Track Upload Status",permalink:"/docs/advanced/tags"},next:{title:"SWAP Bandwidth Accounting",permalink:"/docs/advanced/swap"}},c=[{value:"Persistence on your own node by local pinning",id:"persistence-on-your-own-node-by-local-pinning",children:[]},{value:"Persistence in the network by global pinning",id:"persistence-in-the-network-by-global-pinning",children:[{value:"Become a global pinner",id:"become-a-global-pinner",children:[]},{value:"Request files which are globally pinned",id:"request-files-which-are-globally-pinned",children:[]},{value:"What is a target",id:"what-is-a-target",children:[]}]}],l={rightToc:c};function h(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"The storage capacity of the whole Swarm network equals the the sum of the storage capacity of all connected nodes. As nobody is restricted to upload content to Swarm, eventually the storage capacity of the Swarm network reaches its limits and nodes face the choice to either stop accepting new chunks or delete content which is there already for a while. "),Object(i.b)("p",null,"As Swarm nodes are programmed to behave economically, they won't stop accepting new chunks. The reasoning for this is that newly uploaded chunks are most likely to be accessed, offering the node an opportunity for profit. Instead, they will delete some chunks to make space for the new ones. The chunks that are deleted are the ones which were uploaded or accessed furthest away in the past."),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"The garbage collection queue deletes chunks which were uploaded or ",Object(i.b)("strong",{parentName:"p"},"accessed")," furthest away in the past. This means that you can persist your chunks by regularly accessing it (or making it super duper awesome, so other people access it)"))),Object(i.b)("h2",{id:"persistence-on-your-own-node-by-local-pinning"},"Persistence on your own node by local pinning"),Object(i.b)("p",null,"It is possible to instruct your node never to delete certain chunks, by locally pinning the chunks. Locally pinning chunks means that you will always be able to access these chunks via your node. However, it doesn't does mean that those chunks always be available in the network."),Object(i.b)("p",null,"Locally pinning a chunk is best done upon upload by passing the ",Object(i.b)("inlineCode",{parentName:"p"},"swarm-pin")," header to the upload you are doing. As an example, you can upload a file and pin it at the same time by using"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),'curl -H "Content-Type: image/x-jpeg" -H "swarm-pin: true" --data-binary @kitten.jpg localhost:8080/files?name=cat.jpg\n')),Object(i.b)("h2",{id:"persistence-in-the-network-by-global-pinning"},"Persistence in the network by global pinning"),Object(i.b)("p",null,"Global pinning adds a mechanism such that chunks which are locally pinned become globally available to the network. "),Object(i.b)("h3",{id:"become-a-global-pinner"},"Become a global pinner"),Object(i.b)("p",null,"To become a global pinner, you must:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"start your node in ",Object(i.b)("inlineCode",{parentName:"li"},"global-pinning")," mode;"),Object(i.b)("li",{parentName:"ol"},"make sure that you persist the files. "),Object(i.b)("li",{parentName:"ol"},"advertise that you are a global pinner;")),Object(i.b)("h4",{id:"start-your-node-in-global-pinning-mode"},"Start your node in global pinning mode"),Object(i.b)("p",null,"Starting a node in global pinning mode is done with our standard configuration options (see ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/getting-started/start-your-node"}),"start"),"). The flag which you pass to the command line is ",Object(i.b)("inlineCode",{parentName:"p"},"--global-pinning-enable"),"."),Object(i.b)("p",null,"This mode makes your node to listen to PSS (Postal Service over Swarm) messages, containing requests for repair. If your node receives a request for repair and you store the chunk for which repair is requested, your node will re-upload this chunk to its natural location in the network."),Object(i.b)("h4",{id:"persist-the-files"},"Persist the files"),Object(i.b)("p",null,"Persisting the files is advertised to be done in the ",Object(i.b)("inlineCode",{parentName:"p"},"local pinning")," feature. However, this is not obligatory; As long as you make sure that you persist the files and have them available at the moment that the recovery mechanism is set in motion (after receiving a PSS message) all is fine."),Object(i.b)("h4",{id:"advertise-as-a-global-pinner"},"Advertise as a global pinner"),Object(i.b)("p",null,"By only starting your node in global pinning mode, nodes will still not know that they need to reach out to you for repair. You must somehow report that you are globally pinning the files (and this information must be picked up by any person who downloads the content you are globally pinning). "),Object(i.b)("p",null,"The Swarm team envisions multiple ways how this is possible: via smart-contracts, via special gateways to the Swarm network, via Manifests, as data in the root chunk, via a feed or many other ways. "),Object(i.b)("p",null,"We deliberately didn't force a specific pattern to the user, and we also don't aim to do so in the future. However, when a certain pattern to advertise yourself as a global pinner becomes the de-facto standard, we will report it here."),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"As a global pinner, you don't need to advertise your full overlay address. You only need to advertise your overlay addres as a ",Object(i.b)("em",{parentName:"p"},"target"),' which is the first n characters of your overlay address, where n increases if the number of nodes in the network increases. (see "what is a target").'))),Object(i.b)("h3",{id:"request-files-which-are-globally-pinned"},"Request files which are globally pinned"),Object(i.b)("p",null,"To make use of the global pinning feature (and request a repair if a chunk not found), you need to pass a ",Object(i.b)("inlineCode",{parentName:"p"},"targets"),' query parameter to your upload request. The value of this parameter is a reference to the address of the global pinner node. You don\'t need to pass his whole address, just the first n characters is sufficient (where n increases if the number of nodes in the network increases). Please see "What is a target" below.'),Object(i.b)("p",null,"An example of a request to download a file with the targets query parameter passed in:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"curl http://localhost:8080/files/3b2791985f102fe645d1ebd7f51e522d277098fcd86526674755f762084b94ee?targets=<target comes here>\n")),Object(i.b)("p",null,"If your chunk is not found in the network, but you sent a request to the passed-in target for repair then you get a ",Object(i.b)("inlineCode",{parentName:"p"},"202")," response back, indicating that the request has been accepted for processing."),Object(i.b)("p",null,"After few seconds, You can retry to download the chunk again and this time the network will respond back with the repaired chunk. If you still don't get the chunk back, try downloading the chunk with another target."),Object(i.b)("h4",{id:"how-to-find-out-which-targets-to-pass"},"How to find out which targets to pass"),Object(i.b)("p",null,"Just as there is no set way how to advertise that your node is a global pinner, there is no set way on how to figure out which nodes are global pinners for which content. The burden to pass targets in a request should ultimately not be borne by the user; we envision that the code that interacts with the bee client handles finding the target and passing it in with the request."),Object(i.b)("h3",{id:"what-is-a-target"},"What is a target"),Object(i.b)("p",null,"A target is defined as the first n-characters of an overlay address. In order for PSS to guarantee delivery to the destination, the bit-length of the target must be longer than the neighborhood depth of the node. As the neighborhood depth is defined as log2(N/R), where N is the amount of nodes in the network and R is the neighborhood size or redundancy factor."),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"For a few hundred of nodes in the network, we advice the length of the target to be 2 bytes. From about 50000 nodes onwards, you should start considering a target length of 3 bytes. "))),Object(i.b)("p",null,"To understand this a deeper, you should realize that a recipient node is only guaranteed to receive a message if the chunk, containing the message falls into the neighborhood of the recipient. Falling into the recipients's neighbourhood means the recipient's overlay address matches the chunk's address on a prefix with bit-length greater or equal to the neighbourhood depth of the recipient.  The neighbourhood depth is logarithmic in the network size.  Its expected value  is log2(N/R)  where R is the neighbourhood  size or redundancy factor. Now if the network has a thousand nodes (N=2^10) and a redundancy factor of 4 (R=4=2^2), the expected depth is 8. However, due to variance some nodes will have depth of 9, which means that a trojan generated with a one-byte target (guaranteed 8 bits matching) will only have 50% chance of hitting the node's neighbourhood."),Object(i.b)("p",null,"The conclusion  is that already at a good few hundred  nodes, one needs  2-byte targets."))}h.isMDXComponent=!0}}]);